## 서블릿 필터, 인터셉터, AOP  왜 필요할까?

- 공통관심사항 때문이다.

예시) 

로그인한 사용자만 상품 관리 페이지에 들어갈 수 있어야 한다.
로그인을 하지 않은 사용자는 상품관리 버튼이 보이지 않기 때문에 문제가 없어 보이지만!
로그인하지 않은 사용자가 URL을 직접 호출하면 상품 관리 화면에 들어갈 수 있게된다!
>예시) http://localhost:8080/items 로 강제 접속해버리기

**예상되는 해결법**

상품관리 컨트롤러에서 로그인 여부를 체크하는 로직을 하나하나 작성하면 해결된다.
그러나! 등록, 수정, 삭제, 조회 등등 상품관리의 모든 컨트롤러 로직에 로그인 여부 확인하는 로직을 다 넣어야한다.
더 큰 문제는 향후 로그인 관련 로직이 바뀔때마다 → 작성항 로직을 다 수정해야한다.
이처럼 애플리케이션 여러 로직에서 공통으로 관심이 있는 것을 `공통 관심사` 라고 한다. 
위의 예시에서는 등록, 수정, 삭제, 조회 등등 에서 공통으로 `인증!` (로그인 했는지)에 대한 관심을 가지고 있다.

**공통 관심사는 스프링의 AOP로도 해결할 수 있지만, ⇒ 웹과 관련된 공통 관심사는 서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다.**

**웹과 관련된 공통 관심사를 처리할때는 HTTP의 헤더나 URL의 정보들이필요한데, 서블릿 필터, 스프링 인터셉터는 `HttpServletRequest`를 제공하기 때문이다.**

- 필터, 인터셉터는 웹과 관련된 부가적인 기능들이 있다.
- AOP는 부가 기능이 없다.

----
## 서블릿 필터 소개

필터는 서블릿이 지원하는 수문장 역할이다. (어떤 요청을 걸러주는 역할, 쭉 읽어보면 이해감)

클라이언트의 HTTP 요청 전 후로 어떤 처리를 해준다.

`Dispatcher Servlet`에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리하는 객체이다.
![](https://velog.velcdn.com/images/siontext/post/0ab279ea-5624-4316-acfc-d8b245febb75/image.png)

### 필터의 흐름
> ** `HTTP 요청` → `WAS` → `필터` → `서블릿` → `컨트롤러`**

- 만약 필터를 적용하면 필터가 호출된 다음 → 서블릿이 호출된다.
- 따라서 모든 고객의 요청 로그를 남기는 요구사항이 있다면 필터를 사용하면 된다.
- 필터는 특정 URL 패턴에 적용할 수 있다 `/*` 이라고 하면 모든 요청에 필터가 적용된다.
- 참고로 스프링을 사용하는 경우 여기서 말하는 서블릿은 디스패처 서블릿으로 생각하면 된다.


### 필터의 제한 기능
>**`HTTP 요청` → `WAS` → `필터` → `서블릿` → `컨트롤러` //로그인 사용자**
>**`HTTP 요청` → `WAS` → `필터`(적절하지 않은 요청이라 판단, 서블릿 호출 X) //비 로그인 사용자**

- 필터를 통해 적절하지 않은 요청이라고 판단하면 필터에서 끝을 낼 수 있다 → 따라서 로그인 여부를 체크하기 딱 좋다.
- 로그인한 사용자만 컨트롤러를 호출해줘 → 제한을 걸 수 있다.
- 예를들어 “로그인한 사용자만 컨트롤러를 호출할 수 있게 필터를 걸러줘~”

### 필터 체인 기능

> **`HTTP 요청` → `WAS` → `필터1` → `필터2` → `필터3` → `서블릿` → `컨트롤러`**

- 필터는 체인으로 구성된다. (필터를 여러개 걸수 있다.)
- 중간에 필터를 자유롭게 추가할 수 있다.
- 예를 들어 로그를 남기는 필터를 적용하고 → 그 다음 로그인 여부를 체크하는 필터를 만들 수 있다.


### 필터 인터페이스

```java
public interface Filter {
		public default void init(FilterConfig filterConfig) throws ServletException
		{}
	
		public void doFilter(ServletRequest request, ServletResponse response,
								FilterChain chain) throws IOException, ServletException;
	
		public default void destroy() {}
}
```

필터 인터페이스를 구현하고 등록하면 → 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고 관리한다. (따라서 스프링 빈 처럼 필터가 1개만 등록이 되어서 사용된다.)


### 필터 인터페이스가 제공하는 메서드들

- `init()` : 필드 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
- `doFilter()`: 고객의 요청이 올 때마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다 (실질적 필터기능)
- `destory()`: 필터종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.

중요한것은 `doFilter()` 메서드
`doFilter()`를 호출하고 `doFilter()`를 통과 통과 한다음에 → 서블릿이 호출된다

----------

스프링 인터셉터가 필터보다 많은 기능을 제공하고 좋다 (영한님 피셜)

## 스프링 인터셉터란?

말그대로 낚아채다. 
서버에 들어온 Request객체를 컨트롤러에 도달하기 전에 낚아채서 개발자가 원하는 추가적인 작업을 한 후 컨트롤러로 보낼 수 있도록 해주는 것이 `인터셉터` 이다.

### 서블릿 필터와 차이점

서블릿 필터와 같이 웹과 관련된 공통 관심사항을 효과적으로 해결할 수 있는 기술이다.
서블릿 필터는 서블릿이 제공하는 기술  ↔ 스프링 인터셉터는 스프링 MVC가 제공하는 기술이다.
둘다 웹과 관련된 공통 관심 사항을 처리하지만, 적용되는 순서와 범위, 그리고 사용방법이 다르다.

### 스프링 인터셉터의 흐름


> **`HTTP 요청` → `WAS` → `필터` → `서블릿` → `스프링 인터셉터` → `컨트롤러`**
![](https://velog.velcdn.com/images/siontext/post/fc9ae44c-63dc-4eab-bfe9-8dd8bff6cd89/image.png)


- 스프링 인터셉터는 `디스패처 서블릿`과 `컨트롤러` 사이에서 `컨트롤러 호출 직전에 호출`된다.
- 스프링 MVC가 제공하는 기능이기에 결국 디스패처 서블릿 이후에 등장하게 된다.
    - 스프링 MVC의 시작점이 디스패처 서블릿이라 생각하면 된다
- URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과 다르고 매우 정밀하게 설정할 수 있다.


### 스프링 인터셉터의 제한 기능
> **`HTTP 요청` → `WAS` → `필터` → `서블릿` → `스프링 인터셉터` → `컨트롤러` //로그인 사용자**
> **`HTTP 요청` → `WAS` → `필터` → `서블릿` → `스프링 인터셉터`(적절하지 않은 요청이라 판단, 컨트롤러 호출 X) //비로그인 사용자**

인터셉터에서 적절하지 않은 요청이라고 판단하면 거기서 끝을낼 수 있다 → 따라서 로그인 여부를 체크하기 딱 좋다.


### 스프링 인터셉터의 체인 기능
> **`HTTP 요청` → `WAS` → `필터` → `서블릿` → `인터셉터1` → `인터셉터2` → `컨트롤러`**


인터셉터는 체인으로 구성된다. (인터셉터 여러개 걸 수 있다)
중간에 인터셉터를 자유롭게 추가할 수 있다.
예를들어 로그를 남기는 인터셉터를 먼저 적용하고 → 그 다음에 로그인 여부를 체크하는 인터셉터를 만들 수 있다.
- 뭔가 서블릿 필터와 호출순서만 다르고 제공기능은 비슷해 보인다. 그러나 인터셉터가 더 편하고 더 정교하고 다양한 기능을 지원한다.

### 인터셉터 인터페이스
```java
public interface HandlerInterceptor {
		default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {}
        
		default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {}

		default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {}
}
```
인터셉터를 사용하려면 HandlerInterceptor 인터페이스를 구현하면 된다.

### 인터셉터 인터페이스가 제공하는 메서드들
>- 서블릿 필터의 경우 단순하게 게 `doFilter()` 하나만 구현해도 됐다. (핵심로직).
>- 인터셉터는 컨트롤러의
>    - 호출 전( `preHandle` )
>    - 호출 후( `postHandle` ),
>    - HTTP 요청 완료 이후( `afterCompletion` ) 같이 단계적으로 세분화 되어있다.

매개변수를 확인해보면 서블릿 필터의 경우 단순히 request , response 만 제공했지만 
인터셉터는 `어떤 컨트롤러( handler )가 호출되는지` 호출 정보도 받을 수 있다. 
그리고 `어떤 modelAndView 가 반환되는지` 응답 정보도 받을 수 있다.

### 스프링 인터셉터 메서드들의 호출 흐름
![](https://velog.velcdn.com/images/siontext/post/5927188e-566c-453a-959d-e434a37dbd78/image.png)
1. **정상 작동시**
- `preHandle()`
    - 컨트롤러 호출 전에 호출된다
    - `preHandle()` 의 응답값이 `true` 이면 다음으로 진행한다.  `false` 이면 더는 진행하지 않는다(`preHandle()`의 반환 타입은 boolean 타입이다)
    - `false` 인 경우 나머지 인터셉터는 물론이고, 핸들러 어댑터도 호출되지 않는다
    - 따라서 그림 1번에서 끝나버린다.
- `postHandle()`
    - 컨트롤러 호출 후에 호출된다.
- `afterCompletion()`
    - 뷰가 렌더링 된 이후에 호출된다.
    
    ![](https://velog.velcdn.com/images/siontext/post/dea33f08-3b1e-40b9-b65e-d250ff36cf78/image.png)
2. **컨트롤러에 예외 발생시**
- `preHandle()`
    - 컨트롤러 전에 호출된다.
- `postHandle()`
    - 컨트롤러에서 예외가 발생하면 `postHandle()`은 호출되지 않는다.
- `afterCompletion()`
    - `afterCompletion()` 은 항상 호출된다. 이 경우엔 예외를 파라미터로 받아서 → 어떤 예외가 발생했는지 로그로 출력할 수 있다. (매개변수에 예외클래스가 있다)

### afterCompletion은 예외가 발생해도 호출된다.
- 예외가 발생하면 `postHandle()`메서드는 호출되지 않는다 .
- 따라서 예외와 무관하게 공통처리를 하려면 → `afterCompletion()`을 사용해야 한다.
- 즉 예외가 발생하면 `afterCompletion()`에 **예외정보를 담아서 호출한다.**

### 정리!!!
인터셉터는 **스프링 <u/>MVC 구조에 특화된 필터</u> 기능을 제공한다고 이해하면 되겠다.**
만약 스프링 MVC를 사용하고 있고, 필터를 꼭! 사용해야 하는 상황이 아니라면 → 인터셉터를 사용하면 되겠다!!!

**질문**
JWT를 사용하면 서블릿 필터가 사용된다고 들었는데요
왜 인터셉터를 사용해서 JWT를 구현하지 않는 걸까요??
